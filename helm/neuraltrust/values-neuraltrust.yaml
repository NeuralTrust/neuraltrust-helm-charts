global:
  openshift: false # set to true if you are using openshift
  security:
    allowInsecureImages: true # Allow Bitnami charts to use their container images

# Helm dependency configurations (for clickhouse and kafka subcharts)
# These override the full name to remove the release name prefix
# This ensures services are named "clickhouse" and "kafka" instead of "data-plane-clickhouse" and "data-plane-kafka"
clickhouse:
  fullnameOverride: "clickhouse"

kafka:
  fullnameOverride: "kafka"

dataPlane:
  enabled: true
  preserveExistingSecrets: false  # If true, existing secrets in the cluster will not be replaced during upgrades
  secrets:
    openaiApiKeySecretName: "openai-secrets" # Secret name for OpenAI key
    # You can provide either a direct value (string) or a secret reference (object)
    # Direct value example: openaiApiKey: "sk-..."
    # Secret reference example: openaiApiKey: {secretName: "existing-secret", secretKey: "OPENAI_API_KEY"}
    openaiApiKey: ""  # Define this value or use secret reference
    googleApiKeySecretName: "google-secrets" # Secret name for Google key
    googleApiKey: ""  # Define this value or use secret reference
    resendApiKeySecretName: "resend-secrets" # Secret name for Resend key
    resendApiKey: ""  # Define this value or use secret reference
    dataPlaneJWTSecretName: "data-plane-jwt-secret" # Secret name for Data Plane JWT
    dataPlaneJWTSecret: ""  # Define this value or use secret reference
    huggingFaceTokenSecretName: "huggingface-secrets" # Secret name for Hugging Face token
    huggingFaceToken: ""  # Define this value or use secret reference
  components:
    clickhouse:
      enabled: true
      backup:
        enabled: false
        type: "s3"  # s3 or gcs
        image:
          repository: "curlimages/curl"
          tag: "8.13.0"
        s3:
          bucket: ""  # Define this value
          region: ""  # Define this value
          accessKey: ""  # Define this value
          secretKey: ""  # Define this value
          endpoint: ""  # Optional, for custom S3-compatible endpoints
        gcs:
          bucket: ""  # Define this value
          accessKey: ""  # Define this value
          secretKey: ""  # Define this value
      auth:
        username: "neuraltrust"
      image:
        repository: "clickhouse/clickhouse-server"
        tag: "25.3.2"
        pullPolicy: "Always"
        imagePullSecrets:
          - name: ""
      # Connection configuration
      host: "clickhouse"
      port: "8123"
      user: "neuraltrust"
      database: "neuraltrust"
      # Configuration references
      secrets:
        name: "clickhouse-secrets"
      configmap:
        name: "clickhouse-init-job"
      resources:
        requests:
          memory: 512Mi
          cpu: 250m
        limits:
          memory: 1Gi
          cpu: 500m
    kafka:
      enabled: true
      connect:
        replicas: 1
        # Bootstrap servers for Kafka Connect to connect to Kafka broker
        # Leave empty to auto-detect based on kafka.fullnameOverride or release name
        # Examples:
        #   - With fullnameOverride="kafka": "kafka-broker-0.kafka-broker-headless.neuraltrust.svc.cluster.local:9094"
        #   - Without fullnameOverride (release="data-plane"): "data-plane-kafka-broker-0.data-plane-kafka-broker-headless.neuraltrust.svc.cluster.local:9094"
        #   - Custom: Set this value explicitly
        bootstrapServers: ""  # Auto-detected if empty
        image:
          repository: europe-west1-docker.pkg.dev/neuraltrust-app-prod/nt-docker/kafka-connect
          tag: v0.0.1
          pullPolicy: Always
          imagePullSecrets:
            - name: ""
        resources:
          limits:
            cpu: "1"
            memory: 4Gi
          requests:
            cpu: 500m
            memory: 2Gi
      broker:
        replicas: 1
        imagePullSecrets:
          - name: ""
        resources:
          requests:
            memory: 1Gi
            cpu: 500m
          limits:
            memory: 2Gi
            cpu: 1
    api:
      enabled: true
      host: "data-plane-api.neuraltrust.ai" # set to your domain
      service:
        type: LoadBalancer
      ingress:
        enabled: true
        className: "nginx"  # Set to your ingress controller class (e.g., "nginx", "traefik", "haproxy")
        annotations:
          cert-manager.io/cluster-issuer: "letsencrypt-issuer"
          nginx.ingress.kubernetes.io/ssl-redirect: "true"
          nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
          nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
          nginx.ingress.kubernetes.io/x-frame-options: "DENY"
          nginx.ingress.kubernetes.io/x-content-type-options: "nosniff"
          nginx.ingress.kubernetes.io/x-xss-protection: "1; mode=block"
          nginx.ingress.kubernetes.io/proxy-body-size: "50m"
          nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"
          nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
          nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
          nginx.ingress.kubernetes.io/enable-cors: "true"
          nginx.ingress.kubernetes.io/cors-allow-origin: "https://*"
          nginx.ingress.kubernetes.io/cors-allow-methods: "PUT, GET, POST, OPTIONS, DELETE, PATCH"
          nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,token,Token,Content-Length,Accept,Origin,Token,token"
        tls:
          enabled: true
          secretName: ""  # Leave empty to auto-generate per-service secrets
      classifierModel: "gpt"
      image:
        repository: europe-west1-docker.pkg.dev/neuraltrust-app-prod/nt-docker/data-plane-api
        tag: v1.6.2
        pullPolicy: Always
        imagePullSecrets:
          - name: gcr-secret
      accessMode: ReadWriteOnce
      huggingfaceToken: ""  # Define this value
      storage: 10Gi
      # TrustTest Configuration (.trusttest_config.json)
      trustTestConfig:
        evaluator:
          provider: "google"
          model: "gemini-2.0-flash"
          temperature: 0.2
          retry_config:
            attempts: 3
        translation:
          provider: "google"
          model: "gemini-2.0-flash"
          temperature: 0.2
          retry_config:
            attempts: 3
        question_generator:
          provider: "google"
          model: "gemini-2.0-flash"
          temperature: 0.5
          retry_config:
            attempts: 3
        translation:
          provider: "google"
          model: "gemini-2.0-flash"
          temperature: 0.5
          retry_config:
            attempts: 3
        embeddings:
          provider: "openai"
          model: "text-embedding-3-small"
        topic_summarizer:
          provider: "google"
          model: "gemini-2.0-flash"
          temperature: 0.2
          retry_config:
            attempts: 3
      replicas: 4
      resources:
        requests:
          cpu: 1
          memory: 2Gi
        limits:
          cpu: 2
          memory: 3Gi
    worker:
      enabled: true
      replicas: 1
      image:
        repository: europe-west1-docker.pkg.dev/neuraltrust-app-prod/nt-docker/workers
        tag: v1.4.0-with-models
        pullPolicy: Always
        imagePullSecrets:
          - name: gcr-secret
      resources:
        requests:
          memory: 4Gi
          cpu: 1000m
        limits:
          memory: 8Gi
          cpu: 2000m
    connectorsJob: # New section for the create-connectors job
      image: curlimages/curl:8.13.0 # Default image for create-connectors job


controlPlane:
  enabled: true
  preserveExistingSecrets: false  # If true, existing secrets in the cluster will not be replaced during upgrades
  secrets:
    # You can provide either a direct value (string) or a secret reference (object)
    # Direct value example: controlPlaneJWTSecret: "my-secret-value"
    # Secret reference example: controlPlaneJWTSecret: {secretName: "existing-secret", secretKey: "CONTROL_PLANE_JWT_SECRET"}
    controlPlaneJWTSecret: ""  # Define this value or use secret reference
    openaiApiKey: ""  # Define this value or use secret reference
    resendApiKey: ""  # Define this value or use secret reference
    resendAlertSender: ""  # Define this value or use secret reference
    resendInviteSender: ""  # Define this value or use secret reference
    trustgateJwtSecret: ""  # Define this value or use secret reference
    firewallJwtSecret: ""  # Define this value or use secret reference
    modelScannerSecret: ""  # Define this value or use secret reference
  components:
    scheduler:
      enabled: true
      host: "control-plane-scheduler.neuraltrust.ai" # set to your domain
      service:
        type: LoadBalancer
      ingress:
        enabled: true
        className: "nginx"  # Set to your ingress controller class (e.g., "nginx", "traefik", "haproxy")
        annotations:
          cert-manager.io/cluster-issuer: "letsencrypt-issuer"
          nginx.ingress.kubernetes.io/ssl-redirect: "true"
          nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
          nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
          nginx.ingress.kubernetes.io/x-frame-options: "DENY"
          nginx.ingress.kubernetes.io/x-content-type-options: "nosniff"
          nginx.ingress.kubernetes.io/x-xss-protection: "1; mode=block"
          nginx.ingress.kubernetes.io/proxy-body-size: "50m"
          nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"
          nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
          nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
          nginx.ingress.kubernetes.io/enable-cors: "true"
          nginx.ingress.kubernetes.io/cors-allow-origin: "https://*"
          nginx.ingress.kubernetes.io/cors-allow-methods: "PUT, GET, POST, OPTIONS, DELETE, PATCH"
          nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,token,Token,Content-Length,Accept,Origin,Token,token"
          nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
        tls:
          enabled: true
          secretName: ""  # Leave empty to auto-generate per-service secrets
      replicaCount: 1  # Standardized naming
      image:
        repository: "europe-west1-docker.pkg.dev/neuraltrust-app-prod/nt-docker/scheduler"
        tag: "v1.4.0"
        pullPolicy: "Always"
        imagePullSecrets:
          - name: gcr-secret
      config:
        dataPlaneApiUrl: ""  # Define this value
      resources:
        requests:
          memory: 256Mi
          cpu: 100m
        limits:
          memory: 512Mi
          cpu: 200m
    api:
      enabled: true
      host: "control-plane-api.neuraltrust.ai" # set to your domain
      service:
        type: LoadBalancer
      ingress:
        enabled: true
        className: "nginx"  # Set to your ingress controller class (e.g., "nginx", "traefik", "haproxy")
        annotations:
          cert-manager.io/cluster-issuer: "letsencrypt-issuer"
          nginx.ingress.kubernetes.io/ssl-redirect: "true"
          nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
          nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
          nginx.ingress.kubernetes.io/x-frame-options: "DENY"
          nginx.ingress.kubernetes.io/x-content-type-options: "nosniff"
          nginx.ingress.kubernetes.io/x-xss-protection: "1; mode=block"
          nginx.ingress.kubernetes.io/proxy-body-size: "50m"
          nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"
          nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
          nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
          nginx.ingress.kubernetes.io/enable-cors: "true"
          nginx.ingress.kubernetes.io/cors-allow-origin: "https://*"
          nginx.ingress.kubernetes.io/cors-allow-methods: "PUT, GET, POST, OPTIONS, DELETE, PATCH"
          nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,token,Token,Content-Length,Accept,Origin,Token,token"
          nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
        tls:
          enabled: true
          secretName: ""  # Leave empty to auto-generate per-service secrets
      replicaCount: 2  # Standardized naming
      image:
        repository: "europe-west1-docker.pkg.dev/neuraltrust-app-prod/nt-docker/control-plane-api"
        tag: "v1.6.0"
        pullPolicy: "Always"
        imagePullSecrets:
          - name: gcr-secret
      secrets:
        controlPlaneJWTSecret: ""  # Define this value
      config:
        dataPlaneApiUrl: ""  # Define this value
        postgresSsl: false  # Enable SSL for PostgreSQL connections
      resources:
        requests:
          memory: 512Mi
          cpu: 250m
        limits:
          memory: 1Gi
          cpu: 500m
    app:
      enabled: true
      host: "control-plane-app.neuraltrust.ai" # set to your domain
      secondaryHost: ""
      service:
        type: LoadBalancer
      ingress:
        enabled: true
        className: "nginx"  # Set to your ingress controller class (e.g., "nginx", "traefik", "haproxy")
        annotations:
          cert-manager.io/cluster-issuer: "letsencrypt-issuer"
          nginx.ingress.kubernetes.io/ssl-redirect: "true"
          nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
          nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
          nginx.ingress.kubernetes.io/x-frame-options: "DENY"
          nginx.ingress.kubernetes.io/x-content-type-options: "nosniff"
          nginx.ingress.kubernetes.io/x-xss-protection: "1; mode=block"
          nginx.ingress.kubernetes.io/proxy-body-size: "50m"
          nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"
          nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
          nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
          nginx.ingress.kubernetes.io/enable-cors: "true"
          nginx.ingress.kubernetes.io/cors-allow-origin: "https://*"
          nginx.ingress.kubernetes.io/cors-allow-methods: "PUT, GET, POST, OPTIONS, DELETE, PATCH"
          nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,token,Token,Content-Length,Accept,Origin,Token,token"
          nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
        tls:
          enabled: true
          secretName: ""  # Leave empty to auto-generate per-service secrets
      replicaCount: 1
      image:
        repository: "europe-west1-docker.pkg.dev/neuraltrust-app-prod/nt-docker/app"
        tag: "latest"
        pullPolicy: "Always"
        imagePullSecrets:
          - name: gcr-secret
      config:
        nodeEnv: production
        port: 3000
        dataPlaneApiUrl: ""  # Define this value
        openaiModel: "gpt-4o-mini"
        trustgateControlPlaneUrl: "https://admin.neuraltrust.ai"
        trustgateDataPlaneUrl: "https://gateway.neuraltrust.ai"
        firewallApiUrl: "http://firewall-api-prod.firewall-prod.svc.cluster.local:80"
        modelScannerApiUrl: "https://trustscan.neuraltrust.ai/v1"
        kafkaHost: "kafka"
        kafkaPort: "9092"
      resources:
        requests:
          memory: 512Mi
          cpu: 250m
        limits:
          memory: 1Gi
          cpu: 500m
      initContainer:
        resources:
          requests:
            memory: 512Mi
            cpu: 250m
          limits:
            memory: 1Gi
            cpu: 500m
    postgresql:
      installInCluster: false  # set as true to install postgresql in the namespace
      secrets: # external postgresql secrets if installInCluster is false, else secrets for the installed postgresql
        name: "postgresql-secrets"
        user: "postgres"
        password: ""  # Define this value
        database: "develop"
        host: "" # Define this value
        port: "5432"
      image: # only used if installInCluster is true
        repository: "postgres"
        tag: "17.2-alpine"
        pullPolicy: "IfNotPresent"
        imagePullSecrets:
          - name: ""
      persistence:
        enabled: true
        size: 10Gi
        storageClass: ""
        preserveOnDelete: true  # If true, PVC will be preserved when Helm release is deleted
      resources: # only used if installInCluster is true
        requests:
          memory: 512Mi
          cpu: 250m
        limits:
          memory: 1Gi
          cpu: 500m
      service: # only used if installInCluster is true
        type: ClusterIP
        port: 5432
